---
title: "Calculate recovery indicators"
author: "Wanda De Keersmaecker"
date: ""
output: rmarkdown::html_vignette
vignette: >
%\VignetteIndexEntry{Calculate recovery indicators}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
  ---
```{r setup, include=FALSE}
  knitr::opts_chunk$set(echo = TRUE, eval = FALSE)
```
  
  
```{r, include=FALSE}
  # source_rmd <- function(file, local = FALSE, ...){
#   options(knitr.duplicate.label = 'allow')
#   
#   tempR <- tempfile(tmpdir = ".", fileext = ".R")
#   on.exit(unlink(tempR))
#   knitr::purl(file, output=tempR, quiet = TRUE)
#   
#   envir <- globalenv()
#   source(tempR, local = envir, ...)
# }
```

*This script calculates a set of recovery indicators from simulated time series, including the RRI, R80P and YrYr recovery indicators, defined by Frazier et al. (2018), and the post-disturbance slope. These indicators can be derived from dense (having more than one observation per year) time series or the dense time series can be converted to annual time series. In addition, the indicators can be calculated using the raw time series, smoothed time series or after trend segmentation.*

*The RRI, R80p and YrYr recovery indicators are originally developped for annual long-term time series of optical vegetation indices. Yet, in order to be able to derive the indicators as well for dense and/or short time series, a modified version is suggested. Here, the user can define the time period before, during and after the disturbance that is used to derive the indicators. To reduce the interference of the seasonal pattern of dense time series, the chosen time period should cover blocks of n years. Moreover, given the potentially high noise levels of dense time series, the mean value instead of the maximum value was used in the formulas.*

*In addition to the recovery indicators defined by Frazier et al. (2018), the slope of the post-disturbance trend segment can be derived as recovery indicator. The latter indicator is only available for trend segmented time series: a segmented trend is fitted in the time series, and the detected break showing the largest change (in absolute values) is assumed to represent the disturbance. The slope of the trend segment after the disturbance is then used as recovery indicator.*

## Import libraries
```{r}
#install.packages('signal')
library(signal)
library(BenchmarkRecovery)
#install.packages('imputeTS')
library(imputeTS)
```
## Inputs

*The following inputs are needed to run the script:*


* __ifolder__: input folder, directory of the simulated time series files
* __ofolder__: output folder, directory where the processed files will be stored
* __basename__: base name of the simulated time series files
* __caseList__: list of parameters. The recovery indicators will be calculated for the simulated time series of these parameters.  
* __funSet__: list of settings for the computation of the recovery indicators. More than one value for each setting is allowed (yet an equal number of values for each parameter is required). The recovery indicators are then derived for each set of values of the setting parameters. 
+ *freq*:  'dense' or 'annual'. Defines the observation frequency. For 'dense' the original frequency is used. For 'annual', the time series are converted to annual frequency.
+ *input*: 'smoothed', 'raw', 'segmented'. Defines the type of time series that is used for the recovery indicators. For 'raw', the simulated time series are directly used to calculate recovery, for 'smooth' a time series smoothing algorithm (Savitsky Golay filter) is used before recovery calculation, for 'BFAST' trend segmentation (BFAST0n) is used.
+ *shortDenseTS*: TRUE or FALSE. If FALSE, the recovery metrics defined by Frazier et al. (2018) are computed, otherwise an adjusted version for short, dense time series is used.
+ *nPre*: in case *shortDenseTS* is TRUE: the number of years before the disturbance used to derive the pre-disturbance values
+ *nDist*: in case *shortDenseTS* is TRUE: the number of months after the disturbance used to derive the value during the disturbance 
+ *nPostMin* and *nPostMax*: in case *shortDenseTS* is TRUE: the post-disturbance values are derived between nPostMin and nPostMax years after the disturbance</font>

```{r}
ifolder <- 'C:\\Users\\keers001\\OneDrive\ -\ WageningenUR\\RETURN\\Data\\RETURN\\20191019_SimulationOptSAR\\Landsat\\SimTS\\pie1\\' #'../Data/'#'C:\\Users\\keers001\\OneDrive\ -\ WageningenUR\\RETURN\\Data\\RETURN\\20191019_SimulationOptSAR\\Landsat\\SimTS\\pie1\\' # folder with data characteristics
ofolder <- 'C:\\Users\\keers001\\OneDrive\ -\ WageningenUR\\RETURN\\Data\\RETURN\\20191019_SimulationOptSAR\\Landsat\\RecInd\\pie1\\' #'../Data/'#'C:\\Users\\keers001\\OneDrive\ -\ WageningenUR\\RETURN\\Data\\RETURN\\20191019_SimulationOptSAR\\Landsat\\SimTS\\pie1' # folder where the simulated time series will be saved
ncores <-  2 # number of cores used for parallel computing

basename <- 'LSTS_RndmSample_NoFire_5_Tree_80_scl_30_npnt_20000_VI'#'toyset'#c('LSTS_RndmSample_NoFire_5_Tree_80_scl_30_npnt_20000_VI_VI')# base name of the data files
caseList <- c('distT', 'nyr','seasAmp','remSd', 'distMag','distT', 'distRec', 'missVal')#c('distT','nDr', 'nyr','seasAmp','remSd', 'distMag','distT', 'distRec', 'missVal')#) c('distMag','missVal') # simulation cases to be evaluated
funSet <- list('freq' = c('annual', 'dense','dense','dense','dense','dense','dense'),
               'input' = c('raw','raw', 'smoothed', 'segmented', 'raw', 'smoothed', 'segmented'),# settings for the recovery indicators
               'shortDenseTS' = c(FALSE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE),
               'nPre' = c(2,2,2,2,2,2,2),
               'nDist' = c(12,1,1,1,12,12,12),
               'nPostMin' = c(4,0,0,0,4,4,4),
               'nPostMax' = c(6,1,1,1,6,6,6),
               'h' = c(0.15,0.15,0.15,0.15,0.15,0.15,0.15))

```
## Extract recovery indicators

```{r}
library(doParallel)
registerDoParallel(cores=ncores)

ccomb <- function(...) {
  args <- list(...)
  lapply(seq_along(args[[1]]), function(i)
    do.call('c', lapply(args, function(a) a[[i]])))
}

# Start the clock
#ptm <- proc.time()

# Initiate 
m_RRI <- list()# measured RRI 
m_R80p <- list()# measured R80p 
m_YrYr <- list()# measured YrYR 
m_SL <- list()# measured SL  

s_RRI <- list()#simulated (true) RRI 
s_R80p <- list()#simulated (true) R80p
s_YrYr <- list()#simulated (true) YrYr
s_SL <- list()# simulated (true) SL

for(si in 1:length(caseList)){# # iterate over simulation cases
  simcase <- caseList[si]
  # simulated time series
  simTS <- loadRData(file = file.path(ifolder, paste0(basename, '_simTS_', simcase, '.rda')))
  # trend component of simulated time series
  simTSTr <- loadRData(file = file.path(ifolder, paste0(basename, '_simTSTr_', simcase, '.rda')))
  # seasonal component of simulated time series
  simTSSeas <- loadRData(file = file.path(ifolder, paste0(basename, '_simTSSeas_', simcase, '.rda')))
  # Disturbance component
  #simTSDist <- loadRData(file = file.path(ifolder, paste0(basename, '_simTSDist_', simcase, '.rda')))
  # Remainder component
  simTSRem <- loadRData(file = file.path(ifolder, paste0(basename, '_simTSRem_', simcase, '.rda')))
  # Settings used to simulate the time series
  simTSParam <- loadRData(file = file.path(ifolder, paste0(basename, '_simTSParam_', simcase, '.rda')))
  
  m <- foreach(rset = 1:length(funSet[[1]]), .packages = 'BenchmarkRecovery') %dopar% {
    
    # for(rset in 1:length(funSet[[1]])){
    
    # iterate over recovery indicator settings
    m_RRIi <- matrix(NA, nrow = length(simTS[[1]]), ncol = length(simTS))# measured RRI
    m_R80pi <- matrix(NA, nrow = length(simTS[[1]]), ncol = length(simTS))# measured R80p
    m_YrYri <- matrix(NA, nrow = length(simTS[[1]]), ncol = length(simTS))# measured YrYR
    m_SLi <- matrix(NA, nrow = length(simTS[[1]]), ncol = length(simTS))# measured YrYR
    s_RRIi <- matrix(NA, nrow = length(simTS[[1]]), ncol = length(simTS))#simulated (true) RRI
    s_R80pi <- matrix(NA, nrow = length(simTS[[1]]), ncol = length(simTS))#simulated (true) R80p
    s_YrYri <- matrix(NA, nrow = length(simTS[[1]]), ncol = length(simTS))#simulated (true) YrYr
    s_SLi <- matrix(NA, nrow = length(simTS[[1]]), ncol = length(simTS))#simulated (true) Slope
    
    # calculate recovery
    for (i in 1:length(simTS)){# iterate over simulation parameter settings
      for (ii in 1:length(simTS[[1]])){# iterate over time series length(simTS[[1]]))
        tsi <- TSdecompress(simTS[[i]][[ii]])
        tsseas <- TSdecompress(simTSSeas[[i]][[ii]])
        nobs <- (simTSParam[[i]][[ii]][['number_yrs']]*simTSParam[[i]][[ii]][['obs_per_year']])
        tm <- 1:(simTSParam[[i]][[ii]]$number_yrs * simTSParam[[i]][[ii]]$obs_per_year)
        
        if(simTSParam[[i]][[ii]]$dist_type == 'exponential'){
          simDist <- exponential(tm, pert = simTSParam[[i]][[ii]]$dist_magn, tpert = simTSParam[[i]][[ii]]$dist_time, thalf = simTSParam[[i]][[ii]]$dist_rec)
        }
        if(simTSParam[[i]][[ii]]$dist_type == 'piecewise'){
          simDist <- piecewise(tm, pert = simTSParam[[i]][[ii]]$dist_magn, tpert = simTSParam[[i]][[ii]]$dist_time, thalf = simTSParam[[i]][[ii]]$dist_rec)
        }
        tsref <-  rep(simTSTr[[i]][[ii]],nobs) +  simDist
        
        tdist <- simTSParam[[i]][[ii]][['dist_time']]# timing disturbance
        obspyr <- simTSParam[[i]][[ii]][['obs_per_year']]
        inp <- funSet$input[rset]
        frq <- funSet[['freq']][rset]
        shortDenseTS <- funSet[['shortDenseTS']][rset]
        nPre <- funSet[['nPre']][rset]
        nDist <- funSet[['nDist']][rset]
        nPostMin <- funSet[['nPostMin']][rset]
        nPostMax <- funSet[['nPostMax']][rset]
        h <- funSet[['h']][rset]
        
        if (frq == 'annual'){
          #convert time series to annual values by selecting date closest to seasonal max
          tsi <- toAnnualTS(tsseas, tsi, obspyr)
          tsref <- toAnnualTS(tsseas, tsref, obspyr)
          tdist <- ceiling(tdist/obspyr)
          obspyr <- 1
        }
        if (inp == 'smoothed'){
          #tmp <- sgolayfilt(na_interpolation(tsi, 'linear'), p=2, n=11)# smooth time series using golay filter
          #tsi[is.na(tsi)==F] <- tmp[is.na(tsi)==F]
          df <- data.frame(dat = tsi,tm = 1:length(tsi))
          ls <- loess(dat  ~ tm, df, span = 0.2)#, span = 0.5
          tmps <- predict(ls, data.frame(tm = 1:length(tsi)), se = TRUE)
          tsi <- tmps$fit
        }
        
        if((inp == 'smoothed') | (inp == 'raw')){
          outp <- calcFrazier(tsi, tdist, obspyr, shortDenseTS, nPre, nDist, nPostMin, nPostMax)
          m_RRIi[ii,i] <- outp$RRI# measured RRI
          m_R80pi[ii,i] <- outp$R80P# measured R80p
          m_YrYri[ii,i] <- outp$YrYr# measured YrYR
          rm(outp)
        }
        if(funSet$input[rset] == 'segmented'){
          outp <- calcBFASTrec(tsi, obspyr, h, shortDenseTS, nPre, nDist, nPostMin, nPostMax)
          m_RRIi[ii,i] <- outp$RRI# measured RRI
          m_R80pi[ii,i] <- outp$R80P# measured R80p
          m_YrYri[ii,i] <- outp$YrYr# measured YrYR
          m_SLi[ii,i] <- outp$Sl# measured YrYR
          #print(outp)
          rm(outp)
        }
        
        # reference indicators
        outp <- calcFrazier(tsref, tdist, obspyr, shortDenseTS, nPre, nDist, nPostMin, nPostMax)
        s_RRIi[ii,i] <- outp$RRI#simulated (true) RRI
        s_R80pi[ii,i] <- outp$R80P#simulated (true) R80p
        s_YrYri[ii,i] <- outp$YrYr
        if(inp == 'segmented'){
          s_SLi[ii,i] <- tsref[tdist+3] - tsref[tdist+2]
        }
        
        #print(outp)
        rm(outp)
        
      }
    }
    
    list(m_RRIi, m_R80pi, m_YrYri, m_SLi, s_RRIi, s_R80pi, s_YrYri, s_SLi)
  }
  m_RRI[[simcase]] <- lapply(m,function(xl) xl[[1]]) #m_RRIi
  m_R80p[[simcase]]<- lapply(m,function(xl) xl[[2]])
  m_YrYr[[simcase]]<- lapply(m,function(xl) xl[[3]])
  m_SL[[simcase]]<- lapply(m,function(xl) xl[[4]])
  s_RRI[[simcase]]<- lapply(m,function(xl) xl[[5]])
  s_R80p[[simcase]]<- lapply(m,function(xl) xl[[6]])
  s_YrYr[[simcase]]<- lapply(m,function(xl) xl[[7]])
  s_SL[[simcase]]<- lapply(m,function(xl) xl[[8]])
  # rm(m_RRIi, m_R80pi, m_YrYri, m_SLi, s_RRIi, s_R80pi, s_YrYri, s_SLi)
  
}

# stop the cluster
stopCluster(cl)

# Stop the clock
#proc.time() - ptm



```

## Export results
Saves the recovery indicators and used recovery settings as RDate file. The following structure of the RData files is being used:

m_RRI, m_R80P, m_YrYr, and m_SL contain the RRI, R80P, YrYr, and post-disturbance slope recovery indicators derived from the simulated time series, respectively. s_RRI, s_R80P, s_YrYr, and s_SL contain the same recovery indicators, but derived from the introduced disturbance signal. The latter are thus consided to be the reference/truth.

Each indicator file contains a named list with *nd* items, each corresponding to a simulation case. Each of the *nd* simulation case items contains *nr* matrices, each corresponding to the settings used to compute the recovery indicator. The matrices have *nc* x *nt* dimensions, and correspond to the number of parameter values for the evaluated parameter and simulated time series, respectively.


```{r}

#-------------------------------------------------
# export: save the recovery indicaters as an Rdata file
save(m_RRI, file=file.path(ofolder, paste0(basename, '_m_RRI.rda')))
save(m_R80p, file=file.path(ofolder, paste0(basename, '_m_R80P.rda')))
save(m_YrYr, file=file.path(ofolder, paste0(basename, '_m_YrYr.rda')))
save(m_SL, file=file.path(ofolder, paste0(basename, '_m_SL.rda')))

save(s_RRI, file=file.path(ofolder, paste0(basename, '_s_RRI.rda')))
save(s_R80p, file=file.path(ofolder, paste0(basename, '_s_R80P.rda')))
save(s_YrYr, file=file.path(ofolder, paste0(basename, '_s_YrYr.rda')))
save(s_SL, file=file.path(ofolder, paste0(basename, '_s_SL.rda')))

save(funSet, file=file.path(ofolder, paste0(basename, '_recSettings.rda')))

```

```{r, include=FALSE}
#-------------------------------------------------
# Plot
#"distT"   "nyr"     "seasAmp" "remSd"   "distMag" "distT"   "distRec" "missVal"

cs <- 'distRec'
# simulated time series
simTS <- loadRData(file = file.path(ifolder, paste0(basename, '_simTS_', cs, '.rda')))
# trend component of simulated time series
simTSTr <- loadRData(file = file.path(ifolder, paste0(basename, '_simTSTr_', cs, '.rda')))
# seasonal component of simulated time series
simTSSeas <- loadRData(file = file.path(ifolder, paste0(basename, '_simTSSeas_', cs, '.rda')))
# Remainder component
simTSRem <- loadRData(file = file.path(ifolder, paste0(basename, '_simTSRem_', cs, '.rda')))
# Settings used to simulate the time series
simTSParam <- loadRData(file = file.path(ifolder, paste0(basename, '_simTSParam_', cs, '.rda')))

m_RRI <- loadRData(file = file.path(ofolder, paste0(basename, '_m_RRI.rda')))
m_R80p <- loadRData(file = file.path(ofolder, paste0(basename, '_m_R80p.rda')))
m_YrYr <- loadRData(file = file.path(ofolder, paste0(basename, '_m_YrYr.rda')))
m_SL <- loadRData(file = file.path(ofolder, paste0(basename, '_m_SL.rda')))
s_RRI <- loadRData(file = file.path(ofolder, paste0(basename, '_s_RRI.rda')))
s_R80p <- loadRData(file = file.path(ofolder, paste0(basename, '_s_R80p.rda')))
s_YrYr <- loadRData(file = file.path(ofolder, paste0(basename, '_s_YrYr.rda')))
s_SL <- loadRData(file = file.path(ofolder, paste0(basename, '_s_SL.rda')))

```

```{r, include=FALSE}
library(zoo)
ii <- 1
op <- par()
  dev.off()
for (i in 1:length(simTSParam)){
  tm <- 1:(simTSParam[[i]][[ii]]$number_yrs * simTSParam[[i]][[ii]]$obs_per_year)
  dt <- as.Date('2000-01-01') + tm
  dtann <- as.Date('2000-01-01') + (0:(simTSParam[[i]][[ii]]$number_yrs-1))*simTSParam[[i]][[ii]]$obs_per_year
  
  if(simTSParam[[i]][[ii]]$dist_type == 'exponential'){
    simDist <- exponential(tm, pert = simTSParam[[i]][[ii]]$dist_magn, tpert = simTSParam[[i]][[ii]]$dist_time, thalf = simTSParam[[i]][[ii]]$dist_rec)
  }
  if(simTSParam[[i]][[ii]]$dist_type == 'piecewise'){
    simDist <- piecewise(tm, pert = simTSParam[[i]][[ii]]$dist_magn, tpert = simTSParam[[i]][[ii]]$dist_time, thalf = simTSParam[[i]][[ii]]$dist_rec)
  }
  
  obspyr <- simTSParam[[i]][[ii]]$obs_per_year
  seas <- simTSTr[[i]][[ii]]+TSdecompress(simTSSeas[[i]][[ii]])
  tsi <- TSdecompress(simTS[[i]][[ii]])
  tsref <- simTSTr[[1]][[1]]+simDist
  tsann <- toAnnualTS(seas, tsi, obspyr) 
  tsannref <- toAnnualTS(seas, tsref, obspyr) 
  
  df <- data.frame(dat = tsi,tm = 1:length(tsi))
  ls <- loess(dat  ~ tm, df, span = 0.2)#, span = 0.5
  tmps <- predict(ls, data.frame(tm = 1:length(tsi)), se = TRUE)
  tssmooth <- tmps$fit   
  
  tsbf <- ts(tsi, frequency = obspyr)
  datapp <- bfastpp(tsi, order = 1, lag = NULL, slag = NULL,
                  na.action = na.omit, stl = 'none')
  if(round(length(tsi[is.na(tsi)==F]) * 0.15) > 2){
  bp <- breakpoints(response ~ trend, data = datapp, h =0.15)##, breaks = nbrks
      # Check if BFAST0n found breakpoints
      if(is.na(bp$breakpoints[1])){# no breakpoint found
        trf <- rep(NA,length(tsi))
        tbp <- NA
      }else{# at least one breakpoint found
        # Extract BFAST trend component and breaks
        cf <- coef(bp)
        # Extract BFAST trend component and breaks
        tbp <- bp$breakpoints #observation number of break
        #tr <- rep(NA,length(tsi))
        indna <- which(is.na(tsi)==F)
        tbp <- indna[tbp]   # correct observation number for missing values
        #tr[is.na(tsi)==F] <- fitted(bptst, length(tbptst))
        #Derive trend component without missing values
        bpf <- c(0, tbp, length(tsi))
        trf <- rep(NA,length(tsi))
        for(ti in 1:(length(bpf)-1)){
          trf[(bpf[ti]+1):bpf[ti+1]] <- cf[ti,1] + ((cf[ti,2]*((bpf[ti]+1):bpf[ti+1])))
        }
        # Find the major break
        dbr <- trf[tbp+1]-trf[tbp]
        tbp <- tbp[which(abs(dbr) == max(abs(dbr)))]
      }}else{
        trf <- rep(NA,length(tsi))
        tbp <- NA
      }
  
  
  par(mar=c(2,2,2,1))
  par(fig=c(0,1,0.66,1))

  plot(zoo(tsi[is.na(tsi)==F],dt[is.na(tsi)==F]),type = 'o', xlab = 'Time', ylab = 'VI', col = 'darkcyan', lw = 2,
       main = paste0('n = ', simTSParam[[i]][[ii]]$number_yrs, ', A = ', round(simTSParam[[i]][[ii]]$seas_amp, digits = 3), ', sd = ', round(simTSParam[[i]][[ii]]$rem_sd, digits = 3), ', Dm = ', round(simTSParam[[i]][[ii]]$dist_magn, digits = 3), ', Dt = ', round(simTSParam[[i]][[ii]]$dist_time/simTSParam[[i]][[ii]]$obs_per_year, digits = 1), ', Dr = ', round(simTSParam[[i]][[ii]]$dist_rec/simTSParam[[i]][[ii]]$obs_per_year, digits = 3), ', ', strtrim(simTSParam[[i]][[ii]]$dist_type,3),', mv = ', round(simTSParam[[i]][[ii]]$miss_val,digits = 3)  ))
  lines(zoo(tsref,dt), col = 'red', lw = 2)
  lines(zoo(seas[is.na(seas)==F],dt[is.na(seas)==F]), col = 'grey', lw = 2)
  lines(zoo(tssmooth,dt), col = 'lightgreen', lw=2)
  lines(zoo(trf,dt), col = 'yellow', lw = 2)
  
  par(fig=c(0,1,0.33,0.66), new=TRUE)
  plot(zoo(tsann,dtann), col = 'darkcyan', lw=2, xlim = c(min(dt),max(dt)))
  lines(zoo(tsannref,dtann), col = 'red', lw=2)
  mtext(paste0("RRI ann= ", s_RRI[[cs]][[1]][ii,i], ' | ', m_RRI[[cs]][[1]][ii,i]),side=1,line=2.5, 
        at=par("usr")[1]-0.05*diff(par("usr")[1:2]),
        cex=(1), adj=0)
  
  mtext(paste0("RRI den, raw, sh= ", round(s_RRI[[cs]][[2]][ii,i],digits = 2), ' | ', round(m_RRI[[cs]][[2]][ii,i],digits = 2)), side=1,line=3.5, 
        at=par("usr")[1]-0.05*diff(par("usr")[1:2]),
        cex=(1), adj=0)
  
   mtext(paste0("RRI den, sm, sh= ", round(s_RRI[[cs]][[3]][ii,i],digits = 2), ' | ', round(m_RRI[[cs]][[3]][ii,i],digits = 2)), side=1,line=4.5, 
        at=par("usr")[1]-0.05*diff(par("usr")[1:2]),
        cex=(1), adj=0)
   
    mtext(paste0("RRI den, seg, sh= ", round(s_RRI[[cs]][[4]][ii,i],digits = 2), ' | ', round(m_RRI[[cs]][[4]][ii,i],digits = 2)), side=1,line=5.5, 
        at=par("usr")[1]-0.05*diff(par("usr")[1:2]),
        cex=(1), adj=0)
  
  mtext(paste0("RRI den, raw, lo= ", round(s_RRI[[cs]][[5]][ii,i],digits = 2), ' | ', round(m_RRI[[cs]][[5]][ii,i],digits = 2)), side=1,line=6.5, 
        at=par("usr")[1]-0.05*diff(par("usr")[1:2]),
        cex=(1), adj=0)
  
  mtext(paste0("RRI den, sm, lo= ", round(s_RRI[[cs]][[6]][ii,i],digits = 2), ' | ', round(m_RRI[[cs]][[6]][ii,i],digits = 2)), side=1,line=7.5, 
        at=par("usr")[1]-0.05*diff(par("usr")[1:2]),
        cex=(1), adj=0)
  
  mtext(paste0("RRI den, seg, lo= ", round(s_RRI[[cs]][[7]][ii,i],digits = 2), ' | ', round(m_RRI[[cs]][[7]][ii,i],digits = 2)), side=1,line=8.5, 
        at=par("usr")[1]-0.05*diff(par("usr")[1:2]),
        cex=(1), adj=0)
  
  
  mtext(paste0("R80P annual= ", round(s_R80p[[cs]][[1]][ii,i],digits = 2), ' | ', round(m_R80p[[cs]][[1]][ii,i],digits = 2)),side=1,line=2.5, 
        at=par("usr")[1]+0.30*diff(par("usr")[1:2]),
        cex=(1), adj=0)
  
  mtext(paste0("R80P den, raw= ", round(s_R80p[[cs]][[2]][ii,i],digits = 2), ' | ', round(m_R80p[[cs]][[2]][ii,i],digits = 2)),side=1,line=3.5, 
        at=par("usr")[1]+0.30*diff(par("usr")[1:2]),
        cex=(1), adj=0)
  
     mtext(paste0("R80P den, sm, sh= ", round(s_R80p[[cs]][[3]][ii,i],digits = 2), ' | ', round(m_R80p[[cs]][[3]][ii,i],digits = 2)), side=1,line=4.5, 
        at=par("usr")[1]+0.30*diff(par("usr")[1:2]),
        cex=(1), adj=0)
   
    mtext(paste0("R80P den, seg, sh= ", round(s_R80p[[cs]][[4]][ii,i],digits = 2), ' | ', round(m_R80p[[cs]][[4]][ii,i],digits = 2)), side=1,line=5.5, 
        at=par("usr")[1]+0.30*diff(par("usr")[1:2]),
        cex=(1), adj=0)
  
  mtext(paste0("R80P den, raw, lo= ", round(s_R80p[[cs]][[5]][ii,i],digits = 2), ' | ', round(m_R80p[[cs]][[5]][ii,i],digits = 2)), side=1,line=6.5, 
        at=par("usr")[1]+0.30*diff(par("usr")[1:2]),
        cex=(1), adj=0)
  
  mtext(paste0("R80P den, sm, lo= ", round(s_R80p[[cs]][[6]][ii,i],digits = 2), ' | ', round(m_R80p[[cs]][[6]][ii,i],digits = 2)), side=1,line=7.5, 
        at=par("usr")[1]+0.30*diff(par("usr")[1:2]),
        cex=(1), adj=0)
  
  mtext(paste0("R80P den, seg, lo= ", round(s_R80p[[cs]][[7]][ii,i],digits = 2), ' | ', round(m_R80p[[cs]][[7]][ii,i],digits = 2)), side=1,line=8.5, 
        at=par("usr")[1]+0.30*diff(par("usr")[1:2]),
        cex=(1), adj=0)
  
  mtext(paste0("YrYr annual= ", round(s_YrYr[[cs]][[1]][ii,i],digits = 2), ' | ', round(m_YrYr[[cs]][[1]][ii,i],digits = 2)),side=1,line=2.5, 
        at=par("usr")[1]+0.65*diff(par("usr")[1:2]),
        cex=(1), adj=0)

  mtext(paste0("YrYr den, raw= ", round(s_YrYr[[cs]][[2]][ii,i],digits = 2), ' | ', round(m_YrYr[[cs]][[2]][ii,i],digits = 2)),side=1,line=3.5, 
        at=par("usr")[1]+0.65*diff(par("usr")[1:2]),
        cex=(1), adj=0)
  
     mtext(paste0("YrYr den, sm, sh= ", round(s_YrYr[[cs]][[3]][ii,i],digits = 2), ' | ', round(m_YrYr[[cs]][[3]][ii,i],digits = 2)), side=1,line=4.5, 
        at=par("usr")[1]+0.65*diff(par("usr")[1:2]),
        cex=(1), adj=0)
   
    mtext(paste0("YrYr den, seg, sh= ", round(s_YrYr[[cs]][[4]][ii,i],digits = 2), ' | ', round(m_YrYr[[cs]][[4]][ii,i],digits = 2)), side=1,line=5.5, 
        at=par("usr")[1]+0.65*diff(par("usr")[1:2]),
        cex=(1), adj=0)
  
  mtext(paste0("YrYr den, raw, lo= ", round(s_YrYr[[cs]][[5]][ii,i],digits = 2), ' | ', round(m_YrYr[[cs]][[5]][ii,i],digits = 2)), side=1,line=6.5, 
        at=par("usr")[1]+0.65*diff(par("usr")[1:2]),
        cex=(1), adj=0)
  
  mtext(paste0("YrYr den, sm, lo= ", round(s_YrYr[[cs]][[6]][ii,i],digits = 2), ' | ', round(m_YrYr[[cs]][[6]][ii,i],digits = 2)), side=1,line=7.5, 
        at=par("usr")[1]+0.65*diff(par("usr")[1:2]),
        cex=(1), adj=0)
  
  mtext(paste0("YrYr den, seg, lo= ", round(s_YrYr[[cs]][[7]][ii,i],digits = 2), ' | ', round(m_YrYr[[cs]][[7]][ii,i],digits = 2)), side=1,line=8.5, 
        at=par("usr")[1]+0.65*diff(par("usr")[1:2]),
        cex=(1), adj=0)
  
  mtext(paste0("SL sh= ", round(s_SL[[cs]][[4]][ii,i],digits = 4), ' | ', round(m_SL[[cs]][[4]][ii,i],digits = 4)), side=1,line=-2.5, 
        at=par("usr")[1]+0.65*diff(par("usr")[1:2]),
        cex=(1), adj=0)
  
  mtext(paste0("SL lo= ", round(s_SL[[cs]][[7]][ii,i],digits = 4), ' | ', round(m_SL[[cs]][[7]][ii,i],digits = 4)), side=1,line=-1.5, 
        at=par("usr")[1]+0.65*diff(par("usr")[1:2]),
        cex=(1), adj=0)
}
```
